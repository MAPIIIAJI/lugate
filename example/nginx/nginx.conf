user www;

worker_processes  auto;

error_log  /var/log/nginx/error.log;

pid        /var/log/nginx/nginx.pid;

events {
    worker_connections  4096;
}

http {
    include       mime.types;
    default_type  application/octet-stream;

    access_log  /var/log/nginx/access.log;

    #sendfile        on;
    #tcp_nopush     on;

    #keepalive_timeout  0;
    keepalive_timeout  65;

    #gzip  on;

    upstream v1 {
      server service03.lugate.loc;
      server service01.lugate.loc;
    }

    upstream v2 {
      server service02.lugate.loc;
    }

    # gateway
    server {
        listen       80;
        server_name  gateway.lugate.loc;

        access_log  /var/log/nginx/gateway_access.log;
        error_log  /var/log/nginx/gateway_error.log;

        location / {
              # MIME type determined by default_type:
              default_type 'application/json';

              content_by_lua_block {
                  -- Load lugate module
                  local Lugate = require "lugate"

                  -- Get new lugate instance
                  local lugate = Lugate:init({
                    routes = {
                      ["^v1%..+"] = "/v1",
                      ["^v2%..+"] = "/v2",
                    }
                  })

                  -- Send multi requst and get multi response
                  responses = {ngx.location.capture_multi(lugate:get_ngx_requests())}
                  batch_responses = {}
                  for _, response in ipairs(responses) do
                    if 200 == response.status then
                      response_body = string.gsub(response.body, '%s$', '')
                      response_body = string.gsub(response_body, '^%s', '')
                      table.insert(batch_responses, response_body)
                    else
                      ngx.say(lugate:get_json_error(Lugate.ERR_INTERNAL_ERROR))
                    end
                  end

                  -- Print responses
                  if 1 == #batch_responses then
                    ngx.say(batch_responses[1])
                  else
                    ngx.print('[' .. table.concat(batch_responses, ",") .. ']')
                  end

                  return
              }
        }

        location /v1 {
            proxy_pass       http://v1;
            proxy_set_header Host service01;
            proxy_set_header X-Real-IP $remote_addr;
        }

        location /v2 {
            proxy_pass       http://v2;
            proxy_set_header Host service02;
            proxy_set_header X-Real-IP $remote_addr;
        }
    }

    # service01
    server {
        listen       80;
        server_name  service01.lugate.loc service01;

        access_log  /var/log/nginx/service01_access.log;
        error_log  /var/log/nginx/service01_error.log;

        location / {
              # MIME type determined by default_type:
              default_type 'application/json';

              content_by_lua_block {
                 ngx.say('{"jsonrpc": "2.0", "result": [19, "server01"], "id": 1}')
              }
        }
    }

    # service02
    server {
        listen       80;
        server_name  service02.lugate.loc service02;

        access_log  /var/log/nginx/service02_access.log;
        error_log  /var/log/nginx/service02_error.log;

        location / {
              # MIME type determined by default_type:
              default_type 'application/json';

              content_by_lua_block {
                 ngx.say('{"jsonrpc": "2.0", "result": [-19, "server02"], "id": 2}')
              }
        }
    }


    # service03
    server {
        listen       80;
        server_name  service03.lugate.loc service01;

        access_log  /var/log/nginx/service03_access.log;
        error_log  /var/log/nginx/service03_error.log;

        location / {
              # MIME type determined by default_type:
              default_type 'application/json';

              content_by_lua_block {
                 ngx.say('{"jsonrpc": "2.0", "result": [19, "server03"], "id": 1}')
              }
        }
    }

}
